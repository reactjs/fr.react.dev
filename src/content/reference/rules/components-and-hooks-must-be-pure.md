---
title: Les composants et les Hooks doivent Ãªtre des fonctions pures
---

<Intro>

Les fonctions pures ne font que des calculs, rien de plus. Elles facilitent la comprÃ©hension de votre code et son dÃ©bogage, et permettent Ã  React d'optimiser automatiquement vos composants et Hooks de faÃ§on fiable.

</Intro>

<Note>

Cette page de rÃ©fÃ©rence couvre des sujets avancÃ©s, et nÃ©cessite une aisance prÃ©alable avec les concepts couverts dans la page [Garder les composants purs](/learn/keeping-components-pure).

</Note>

<InlineToc />

### En quoi la puretÃ© est-elle importanteÂ ? {/*why-does-purity-matter*/}

Un des piliers conceptuels qui font que React est _React_, c'est la _puretÃ©_.  Dire qu'un composant ou Hook est pur, c'est affirmer qu'ilÂ :

* **est idempotent** â€”Â Vous [obtenez toujours le mÃªme rÃ©sultat](/learn/keeping-components-pure#purity-components-as-formulas) lorsque vous l'appelez avec les mÃªmes entrÃ©es, Ã  savoir les props, Ã©tats locaux et contextes pour les composants, et les arguments pour les Hooks.
* **n'a aucun effet de bord dans son rendu** â€”Â Le code des effets de bord devrait tourner [**sÃ©parÃ©ment du rendu**](#how-does-react-run-your-code). Par exemple dans un [gestionnaire d'Ã©vÃ©nements](/learn/responding-to-events), lorsque l'utilisateur interagit avec l'UI et entraÃ®ne une mise Ã  jourÂ ; ou dans un [Effet](/reference/react/useEffect), qui s'exÃ©cute aprÃ¨s le rendu.
* **ne modifie aucune valeur non locale** â€”Â les composants et Hooks ne devraient [jamais modifier les valeurs qui ne sont pas crÃ©Ã©es localement](#mutation) lors du rendu.

Lorsqu'on prÃ©serve la puretÃ© du rendu, React peut comprendre comment prioriser les mises Ã  jour les plus importantes pour que l'utilisateur les voie au plus tÃ´t.  C'est rendu possible par la puretÃ© du renduÂ : puisque les composants n'ont pas d'effets de bord [lors du rendu](#how-does-react-run-your-code), React peut mettre en pause le rendu de composants moins importants Ã  mettre Ã  jour, et n'y revenir que plus tard lorsqu'ils deviennent nÃ©cessaires.

ConcrÃ¨tement, Ã§a signifie que la logique de rendu peut Ãªtre exÃ©cutÃ©e plusieurs fois d'une faÃ§on qui permette Ã  React de fournir une expÃ©rience utilisateur agrÃ©able.  En revanche, si votre composant a un effet de bord Â«Â clandestinÂ Â» (comme par exemple une modification d'une variable globale [lors du rendu](#how-does-react-run-your-code)), lorsque React rÃ©-exÃ©cutera votre code de rendu, vos effets de bord seront dÃ©clenchÃ©s d'une faÃ§on qui ne correspondra pas Ã  vos attentes.  Ã‡a entraÃ®ne souvent des bugs inattendus qui peuvent dÃ©grader l'expÃ©rience utilisateur de votre appli.  Vous pouvez en voir un [exemple dans la page Garder les composants purs](/learn/keeping-components-pure#side-effects-unintended-consequences).

#### Comment React exÃ©cute-t-il votre codeÂ ? {/*how-does-react-run-your-code*/}

React est dÃ©claratifÂ : vous dites Ã  React de _quoi_ faire le rendu, et React dÃ©terminera _comment_ afficher Ã§a au mieux Ã  l'utilisateur.  Pour y parvenir, React a plusieurs phases d'exÃ©cution de votre code.  Vous n'avez pas besoin de tout savoir sur ces phases pour bien utiliser React.  Mais vous devriez avoir au moins une comprÃ©hension de surface des parties du code qui tournent lors du _rendu_, et de celles qui tournent en-dehors.

Le _rendu_, c'est le calcul de la prochaine version de l'apparence de votre UI.  AprÃ¨s le rendu, les [Effets](/reference/react/useEffect) sont _traitÃ©s_ (c'est-Ã -dire qu'ils sont exÃ©cutÃ©s jusqu'Ã  ce qu'il n'en reste plus en attente) *(flushed, NdT)* et sont susceptibles de mettre Ã  jour le calcul, si certains Effets ont un impact sur la mise en page. React rÃ©cupÃ¨re ce nouveau calcul et le compare Ã  celui utilisÃ© pour la version prÃ©cÃ©dente de l'UI, puis il _commite_ le strict minimum de modifications nÃ©cessaires vers le [DOM](https://developer.mozilla.org/fr/docs/Web/API/Document_Object_Model) (ce que l'utilisateur voit en rÃ©alitÃ©) pour le synchroniser sur cette derniÃ¨re version.

<DeepDive>

#### Comment savoir si un code est exÃ©cutÃ© lors du rendu {/*how-to-tell-if-code-runs-in-render*/}

Une heuristique simple pour dÃ©terminer si du code est exÃ©cutÃ© lors du rendu consiste Ã  examiner son emplacementÂ : s'il figure au niveau racine, comme dans l'exemple ci-dessous, il est probable qu'il soit exÃ©cutÃ© lors du rendu.

```js {2}
function Dropdown() {
  const selectedItems = new Set(); // crÃ©Ã© lors du rendu
  // ...
}
```

Les gestionnaires d'Ã©vÃ©nements et les Effets ne sont pas exÃ©cutÃ©s lors du renduÂ :

```js {4-5}
function Dropdown() {
  const selectedItems = new Set();
  const onSelect = (item) => {
    // ce code est dans un gestionnaire dâ€™Ã©vÃ©nements, il ne sera donc exÃ©cutÃ© que
    // lorsque cet Ã©vÃ©nement a lieu 
    selectedItems.add(item);
  }
}
```

```js {4}
function Dropdown() {
  const selectedItems = new Set();
  useEffect(() => {
    // ce code est au sein dâ€™un Effet, il ne sera donc exÃ©cutÃ© quâ€™aprÃ¨s le rendu
    logForAnalytics(selectedItems);
  }, [selectedItems]);
}
```
</DeepDive>

---

## Les composants et les Hooks doivent Ãªtre idempotents {/*components-and-hooks-must-be-idempotent*/}

Les composants doivent toujours renvoyer le mÃªme rÃ©sultat pour les mÃªmes entrÃ©esÂ : props, Ã©tats locaux et contextes.  On parle alors d'_idempotence_. [L'idempotence](https://fr.wikipedia.org/wiki/Idempotence) est un terme popularisÃ© par la programmation fonctionnelle.  C'est l'idÃ©e selon laquelle l'exÃ©cution d'un morceau de code avec les mÃªmes entrÃ©es [produira le mÃªme rÃ©sultat Ã  chaque fois](learn/keeping-components-pure).

Ã‡a implique que _tout_ le code qui est exÃ©cutÃ© [lors du rendu](#how-does-react-run-your-code) soit aussi idempotent, sans quoi la rÃ¨gle ne tient plus.  Par exemple, la ligne de code ci-aprÃ¨s n'est pas idempotente (et par consÃ©quent, la composant non plus)Â :

```js {2}
function Clock() {
  const time = new Date(); // ğŸ”´ ErronÃ©Â : renvoie toujours un rÃ©sultat diffÃ©rentÂ !
  return <span>{time.toLocaleString()}</span>
}
```

`new Date()` n'est pas idempotent puisqu'il renvoie systÃ©matiquement l'instant courant, ce qui changera d'un appel Ã  l'autre.  Lorsque vous faites le rendu du composant ci-dessus, l'heure affichÃ©e Ã  l'Ã©cran sera gelÃ©e sur le moment du rendu.  Pour les mÃªmes raisons, des fonctions comme `Math.random()` ne sont pas idempotentes puisqu'elles renvoient un rÃ©sultat diffÃ©rent Ã  chaque appel, alors que leurs entrÃ©es sont identiques.

Ã‡a ne signifie pas que vous ne devriez _jamais_ utiliser des fonctions non idempotentes telles que `new Date()`Â ; c'est juste que vous devriez les Ã©viter [lors des rendus](#how-does-react-run-your-code). Pour ce genre de cas, vous pouvez _synchroniser_ le dernier moment souhaitÃ© avec le composant en utilisant par exemple un [Effet](/reference/react/useEffect):

<Sandpack>

```js
import { useState, useEffect } from 'react';

function useTime() {
  // 1. Garde trace du moment courant dans un Ã©tat. `useState` reÃ§oit une fonction
  //    dâ€™initialisation comme Ã©tat initial.  Elle ne sera exÃ©cutÃ©e quâ€™une fois lors de lâ€™appel
  //    initial du Hook, afin que le moment courant au moment de cet appel soit utilisÃ© comme
  //    valeur de dÃ©part.
  const [time, setTime] = useState(() => new Date());

  useEffect(() => {
    // 2.Met Ã  jour la date Ã  chaque seconde grÃ¢ce Ã  `setInterval`.
    const id = setInterval(() => {
      setTime(new Date()); // âœ… CorrectÂ : le code non idempotent n'est plus exÃ©cutÃ© Ã  chaque rendu
    }, 1000);
    // 3. Renvoie une fonction de nettoyage pour ne pas faire fuiter le timer `setInterval`.
    return () => clearInterval(id);
  }, []);

  return time;
}

export default function Clock() {
  const time = useTime();
  return <span>{time.toLocaleString()}</span>;
}
```

</Sandpack>

En enrobant l'appel non idempotent `new Date()` dans un Effet, nous dÃ©plaÃ§ons le calcul [hors du rendu](#how-does-react-run-your-code).

Si vous  n'avez pas besoin de synchroniser un Ã©tat externe avec React, vous pouvez aussi envisager un [gestionnaire d'Ã©vÃ©nements](/learn/responding-to-events) si la mise Ã  jour doit rÃ©sulter d'une interaction utilisateur.

---

## Les effets de bord doivent Ãªtre exÃ©cutÃ©s hors du rendu {/*side-effects-must-run-outside-of-render*/}

[Les effets de bord](/learn/keeping-components-pure#side-effects-unintended-consequences) ne devraient pas Ãªtre exÃ©cutÃ©s [lors du rendu](#how-does-react-run-your-code), dans la mesure oÃ¹ React peut faire plusieurs rendus successifs du mÃªme composant pour optimiser l'expÃ©rience utilisateur.

<Note>
Les effets de bord dÃ©signent un ensemble plus large que les Effets. Les Effets sont plus spÃ©cifiquement du code enrobÃ© dans un appel Ã  `useEffect`, tandis que les effets de bord au sens large dÃ©signent tout code qui a un effet observable autre que le rÃ©sultat principal renvoyÃ© Ã  l'appelant.

Les effets de bord sont le plus souvent implÃ©mentÃ©s au sein de [gestionnaires d'Ã©vÃ©nements](/learn/responding-to-events) ou d'Effets. Mais jamais au sein du rendu.
</Note>

Si le rendu doit en effet (ah ah) rester pur, les effets de bord sont nÃ©anmoins nÃ©cessaires afin que votre appli fasse quoi que ce soit d'intÃ©ressant, comme par exemple afficher quelque chose Ã  l'Ã©cranÂ ! L'essence de cette rÃ¨gle, c'est que les effets de bord ne soient pas exÃ©cutÃ©s [lors du rendu](#how-does-react-run-your-code), puisque React est susceptible d'effectuer des rendus multiples d'un composant. La plupart du temps, vous utiliserez des [gestionnaires d'Ã©vÃ©nements](learn/responding-to-events) pour vos effets de bord.  Le recours Ã  un gestionnaire d'Ã©vÃ©nements indique explicitement Ã  React que ce code n'a pas besoin d'Ãªtre exÃ©cutÃ© lors du rendu, ce qui prÃ©serve la puretÃ© de celui-ci.  Si vous avez Ã©puisÃ© toutes les options possibles (et uniquement en dernier recours), vous pouvez aussi implÃ©menter un effet de bord au moyen d'un `useEffect`.

### Quand est-il acceptable d'avoir une mutationÂ ? {/*mutation*/}

#### Mutations locales {/*local-mutation*/}

La mutation est un cas courant d'effet de bordÂ ; en JavaScript elle revient Ã  modifier une valeur non [primitive](https://developer.mozilla.org/fr/docs/Glossary/Primitive). De faÃ§on gÃ©nÃ©rale, les mutations ne sont pas idiomatiques avec React, mais les mutations _locales_ ne posent aucun problÃ¨meÂ :

```js {2,7}
function FriendList({ friends }) {
  const items = []; // âœ… CorrectÂ : crÃ©Ã© localement
  for (let i = 0; i < friends.length; i++) {
    const friend = friends[i];
    items.push(
      <Friend key={friend.id} friend={friend} />
    ); // âœ… CorrectÂ : les mutations locales ne posent pas de souci
  }
  return <section>{items}</section>;
}
```

Il n'est pas nÃ©cessaire de contorsionner votre code pour Ã©viter les mutations locales. Vous pourriez aussi utiliser [`Array.map`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/map) pour plus de concision, mais il n'y a aucun mal Ã  crÃ©er un tableau local puis le remplir [lors du rendu](#how-does-react-run-your-code).

MÃªme s'il semble que nous mutions `items`, il faut bien voir ici que ce code n'opÃ¨re que _localement_Â : cette mutation n'est pas Â«Â persistÃ©eÂ Â» quand le composant fait un nouveau rendu.  En d'autres termes, `items` ne reste en mÃ©moire que le temps du rendu du composant. Puisque nous _recrÃ©ons_ `items` Ã  chaque rendu de `<FriendList />`, le composant renverra bien toujours le mÃªme rÃ©sultat.

En revanche, si `items` Ã©tait crÃ©Ã© hors du composant, il contiendrait des valeurs issues de rendus prÃ©cÃ©dents, dont il se souviendraitÂ :

```js {1,7}
const items = []; // ğŸ”´ ErronÃ©Â : crÃ©Ã© hors du composant
function FriendList({ friends }) {
  for (let i = 0; i < friends.length; i++) {
    const friend = friends[i];
    items.push(
      <Friend key={friend.id} friend={friend} />
    ); // ğŸ”´ ErronÃ©Â : mutation dâ€™une valeur crÃ©Ã©e hors du rendu
  }
  return <section>{items}</section>;
}
```

Quand `<FriendList />` sera de nouveau exÃ©cutÃ©, nous continuerons Ã  ajouter `friends` Ã  `items` Ã  chaque exÃ©cution du composant, entraÃ®nant de multiples doublons dans le rÃ©sultat. Cette version de `<FriendList />` a des effets de bord observables [lors du rendu](#how-does-react-run-your-code) et **enfreint la rÃ¨gle**.

#### Initialisation paresseuse {/*lazy-initialization*/}

L'initialisation paresseuse est elle aussi acceptable mÃªme si elle n'est pas parfaitement Â«Â pureÂ Â»Â :

```js {2}
function ExpenseForm() {
  SuperCalculator.initializeIfNotReady(); // âœ… Correct (si elle nâ€™affecte aucun autre composant)
  // Continue le rendu...
}
```

#### Modifications du DOM {/*changing-the-dom*/}

Les effets de bord qui sont directement visibles pour l'utilisateur ne sont pas autorisÃ©s au sein de la logique de rendu des composants React. En d'autres termes, appeler une fonction composant ne devrait pas, en soi, modifier l'affichage.

```js {2}
function ProductDetailPage({ product }) {
  document.title = product.title; // ğŸ”´ ErronÃ©Â : modifie le DOM
}
```

Une faÃ§on d'obtenir le rÃ©sultat souhaitÃ©, Ã  savoir mettre Ã  jour `document.title` hors du rendu, consiste Ã  [synchroniser le composant avec `document`](/learn/synchronizing-with-effects).

Tant que des appels multiples du composant restent fiables et n'affectent pas le rendu d'autres composants, React n'exige pas que le composant soit 100% pur au sens strict de la programmation fonctionnelle.  Il est plus important que les [composants soient idempotents](/reference/rules/components-and-hooks-must-be-pure).

---

## Les props et l'Ã©tat sont immuables {/*props-and-state-are-immutable*/}

Les props et l'Ã©tat d'un composant sont des [instantanÃ©s](learn/state-as-a-snapshot) immuables. Ne les mutez jamais directement. Passez plutÃ´t de nouvelles props et appelez les fonctions de mise Ã  jour fournies par `useState`.

Vous pouvez considÃ©rer les props et les valeurs d'Ã©tat local comme des instantanÃ©s qui sont mis Ã  jour aprÃ¨s le rendu.  C'est pourquoi vous ne modifiez pas directement les props et variables d'Ã©tatÂ : vous passez plutÃ´t de nouvelles props, et utilisez les fonctions de mise Ã  jour fournies pour indiquer Ã  React que l'Ã©tat a besoin d'Ãªtre mis Ã  jour en vue du prochain rendu du composant.

<<<<<<< HEAD
### Ne modifiez pas directement les props {/*props*/}

Les props sont immuables parce que si vous les mutiez, l'application produirait un rÃ©sultat incohÃ©rent qui serait difficile Ã  dÃ©boguer, dans la mesure oÃ¹ il pourrait marcher ou non suivant les circonstances.
=======
### Don't mutate Props {/*props*/}
Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug as it may or may not work depending on the circumstances.
>>>>>>> 50d6991ca6652f4bc4c985cf0c0e593864f2cc91

```js {2}
function Post({ item }) {
  item.url = new Url(item.url, base); // ğŸ”´ ErronÃ©Â : ne mutez jamais directement les props
  return <Link url={item.url}>{item.title}</Link>;
}
```

```js {2}
function Post({ item }) {
  const url = new Url(item.url, base); // âœ… CorrectÂ : faites plutÃ´t une copie
  return <Link url={url}>{item.title}</Link>;
}
```

### Ne modifiez pas directement les Ã©tats locaux {/*state*/}

`useState` renvoie une variable d'Ã©tat et une fonction de mise Ã  jour pour cet Ã©tat.

```js
const [stateVariable, setter] = useState(0);
```

PlutÃ´t que de modifier directement la variable d'Ã©tat, nous devons appeler la fonction de mise Ã  jour renvoyÃ©e par son `useState`.  Modifier la valeur de la variable d'Ã©tat n'entraÃ®ne pas de mise Ã  jour du composant, laissant vos utilisateurs face Ã  une UI obsolÃ¨te.  Recourir aux fonctions de mise Ã  jour permet d'informer React que l'Ã©tat va changer, et qu'il doit planifier un nouveau rendu pour mettre Ã  jour l'UI.

```js {5}
function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    count = count + 1; // ğŸ”´ ErronÃ©Â : ne mutez jamais directement lâ€™Ã©tat
  }

  return (
    <button onClick={handleClick}>
      Vous avez cliquÃ© {count} fois
    </button>
  );
}
```

```js {5}
function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1); // âœ… CorrectÂ : utilisez la fonction de mise Ã  jour fournie par useState
  }

  return (
    <button onClick={handleClick}>
      Vous avez cliquÃ© {count} fois
    </button>
  );
}
```

---

## HooksÂ : les arguments et valeurs renvoyÃ©es sont immuables {/*return-values-and-arguments-to-hooks-are-immutable*/}

Une fois que vous avez passÃ© des valeurs Ã  un Hook, vous ne devriez plus les modifier.  Tout comme les props en JSX, ces valeurs deviennent immuables une fois passÃ©es Ã  un Hook.

```js {4}
function useIconStyle(icon) {
  const theme = useContext(ThemeContext);
  if (icon.enabled) {
    icon.className = computeStyle(icon, theme); // ğŸ”´ ErronÃ©Â : ne mutez jamais directement vos arguments
  }
  return icon;
}
```

```js {3}
function useIconStyle(icon) {
  const theme = useContext(ThemeContext);
  const newIcon = { ...icon }; // âœ… CorrectÂ : faites plutÃ´t une copie
  if (icon.enabled) {
    newIcon.className = computeStyle(icon, theme);
  }
  return newIcon;
}
```

Un principe important en React, c'est le _raisonnement local_Â : la capacitÃ© Ã  comprendre ce que fait un composant ou Hook rien qu'en regardant son propre code, en isolation.  Les Hooks devraient Ãªtre traitÃ©s comme des Â«Â boÃ®tes noiresÂ Â» lorsqu'ils sont appelÃ©s.  Un Hook personnalisÃ© pourrait par exemple utiliser ses arguments comme dÃ©pendances pour mÃ©moÃ¯ser des valeursÂ :

```js {4}
function useIconStyle(icon) {
  const theme = useContext(ThemeContext);

  return useMemo(() => {
    const newIcon = { ...icon };
    if (icon.enabled) {
      newIcon.className = computeStyle(icon, theme);
    }
    return newIcon;
  }, [icon, theme]);
}
```

<<<<<<< HEAD
Si vous mutiez les arguments des Hooks, la mÃ©moÃ¯sation du Hook personnalisÃ© s'effrondrerait, il est donc important d'Ã©viter Ã§a.
=======
If you were to mutate the Hook's arguments, the custom hook's memoization will become incorrect,  so it's important to avoid doing that.
>>>>>>> 50d6991ca6652f4bc4c985cf0c0e593864f2cc91

```js {4}
style = useIconStyle(icon);         // `style` est mÃ©moÃ¯sÃ© sur base de `icon`
icon.enabled = false;               // ErronÃ©Â : ğŸ”´ ne mutez jamais directement les arguments
style = useIconStyle(icon);         // la mÃ©moÃ¯sation prÃ©cÃ©dente reste utilisÃ©e
```

```js {4}
style = useIconStyle(icon);         // `style` est mÃ©moÃ¯sÃ© sur base de `icon`
icon = { ...icon, enabled: false }; // CorrectÂ : âœ… faites plutÃ´t une copie
style = useIconStyle(icon);         // la nouvelle valeur de `style` est bien calculÃ©e
```

Pour les mÃªmes raisons, il est important de ne pas modifier les valeurs renvoyÃ©es par les Hooks, puisqu'elles peuvent avoir Ã©tÃ© mÃ©moÃ¯sÃ©es.

---

## Les valeurs sont immuables une fois passÃ©es Ã  JSX {/*values-are-immutable-after-being-passed-to-jsx*/}

<<<<<<< HEAD
Ne mutez pas les valeurs que vous avez passÃ©es Ã  JSX.  DÃ©placez la mutation en amont de la crÃ©ation du JSX.
=======
Don't mutate values after they've been used in JSX. Move the mutation to before the JSX is created.
>>>>>>> 50d6991ca6652f4bc4c985cf0c0e593864f2cc91

Lorsque vous utilisez du JSX dans une expression, React Ã©value le JSX avant que le composant ne termine son rendu.  Ã‡a signifie que la mutation ultÃ©rieure de valeurs, aprÃ¨s qu'elles ont Ã©tÃ© exploitÃ©es par JSX, peut produire des UI obsolÃ¨tes, et React ne saura pas qu'il doit mettre Ã  jour le rÃ©sultat du composant.

```js {4}
function Page({ colour }) {
  const styles = { colour, size: "large" };
  const header = <Header styles={styles} />;
  styles.size = "small"; // ğŸ”´ ErronÃ©Â : styles est dÃ©jÃ  utilisÃ© par le JSX ci-dessus
  const footer = <Footer styles={styles} />;
  return (
    <>
      {header}
      <Content />
      {footer}
    </>
  );
}
```

```js {4}
function Page({ colour }) {
  const headerStyles = { colour, size: "large" };
  const header = <Header styles={headerStyles} />;
  const footerStyles = { colour, size: "small" }; // âœ… CorrectÂ : on a crÃ©Ã© une valeur distincte
  const footer = <Footer styles={footerStyles} />;
  return (
    <>
      {header}
      <Content />
      {footer}
    </>
  );
}
```
