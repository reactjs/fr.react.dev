---
title: createRoot
---

<Intro>

`createRoot` vous permet de cr√©er une racine de rendu pour afficher vos composants React dans un n≈ìud DOM du navigateur.

```js
const root = createRoot(domNode, options?)
```

</Intro>

<InlineToc />

---

## R√©f√©rence {/*reference*/}

### `createRoot(domNode, options?)` {/*createroot*/}

Appelez `createRoot` pour cr√©er une racine de rendu React afin d'afficher du contenu dans un √©l√©ment DOM du navigateur.

```js
import { createRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = createRoot(domNode);
```

React cr√©era une racine de rendu associ√©e au `domNode`, puis prendra la main sur la gestion de son DOM.  Une fois la racine cr√©√©e, vous devrez appeler [`root.render`](#root-render) pour afficher un composant React √† l'int√©rieur¬†:

```js
root.render(<App />);
```

Une appli enti√®rement construite en React n'aura g√©n√©ralement qu'un appel √† `createRoot` pour son composant racine.  Une page qui ¬´¬†saupoudre¬†¬ª du React dans certaines de ses parties peut avoir autant de racines distinctes que n√©cessaire.

[Voir d'autres exemples ci-dessous](#usage).

#### Param√®tres {/*parameters*/}

* `domNode`¬†: un [√©l√©ment DOM](https://developer.mozilla.org/fr/docs/Web/API/Element). React cr√©era une racine de rendu pour cet √©l√©ment DOM et vous permettra d'appeler des m√©thodes sur cette racine, telles que `render` pour afficher le contenu produit par React.

* `options` **optionnelles**¬†: un objet avec des options pour la racine React.

<<<<<<< HEAD
  * `onRecoverableError` **optionnel**¬†: fonction de rappel appel√©e lorsque React retombe automatiquement sur ses pieds suite √† une erreur.
  * `identifierPrefix` **optionnel**¬†: un pr√©fixe textuel utilis√© pour les ID g√©n√©r√©s par [`useId`](/reference/react/useId). Pratique pour √©viter les conflits entre les ID au sein de racines multiples sur une m√™me page.
=======
  * <CanaryBadge title="This feature is only available in the Canary channel" /> **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  * <CanaryBadge title="This feature is only available in the Canary channel" /> **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown, and an `errorInfo` object containing the `componentStack`.
  * **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with an `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  * **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.
>>>>>>> c3bc5affa0e7452e306c785af11798d16b4f6dd4

#### Valeur renvoy√©e {/*returns*/}

`createRoot` renvoie un objet avec deux m√©thodes¬†: [`render`](#root-render) et [`unmount`](#root-unmount).

#### Limitations {/*caveats*/}

* Si votre appli b√©n√©ficie d'un premier rendu c√¥t√© serveur, vous ne pourrez pas utiliser `createRoot()`¬†: utilisez plut√¥t [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot).
* Vous n'aurez probablement qu'un seul appel √† `createRoot` dans votre appli. Si vous utilisez un framework, il le fait peut-√™tre pour vous.
* Lorsque vous souhaitez afficher un bout de JSX dans une autre partie du DOM, une partie qui n'est pas un enfant de votre composant (par exemple pour une bo√Æte de dialogue modale ou une infobulle), utilisez [`createPortal`](/reference/react-dom/createPortal) plut√¥t que `createRoot`.

---

### `root.render(reactNode)` {/*root-render*/}

Appelez `root.render` pour afficher un bout de [JSX](/learn/writing-markup-with-jsx) (un ¬´¬†n≈ìud React¬†¬ª) dans le n≈ìud DOM du navigateur associ√© √† la racine React.

```js
root.render(<App />);
```

React affichera `<App />` dans le `root`, et prendra la main sur la gestion du DOM √† l'int√©rieur.

[Voir d'autres exemples ci-dessous](#usage).

#### Param√®tres {/*root-render-parameters*/}

* `reactNode`¬†: un *n≈ìud React* que vous souhaitez afficher. Ce sera g√©n√©ralement un bout de JSX du genre `<App />`, mais vous pouvez aussi passer un √©l√©ment React cr√©√© avec [`createElement()`](/reference/react/createElement), une cha√Æne de caract√®res, un nombre, `null` ou `undefined`.

#### Valeur renvoy√©e {/*root-render-returns*/}

`root.render` renvoie `undefined`.

#### Limitations {/*root-render-caveats*/}

* La premi√®re fois que vous appellez `root.render`, React videra tout le HTML existant au sein de la racine avant de faire le rendu du composant React √† l'int√©rieur

* Si le n≈ìud DOM de votre racine contient du HTML g√©n√©r√© par React c√¥t√© serveur ou lors du *build*, utilisez plut√¥t [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot), qui se contentera d'attacher les gestionnaires d'√©v√©nements au HTML existant.

* Si vous appelez `render` sur la m√™me racine plusieurs fois, React mettra √† jour le DOM si n√©cessaire pour refl√©ter le dernier JSX que vous lui avez pass√©.  React d√©cidera quelles parties du DOM r√©utiliser et lesquelles n√©cessitent une cr√©ation √† froid en [¬´¬†examinant la correspondance¬†¬ª](/learn/preserving-and-resetting-state) entre l'arbre React et celui du pr√©c√©dent rendu.  Appeler `render` √† nouveau sur la m√™me racine est similaire √† un appel de [fonction `set`](/reference/react/useState#setstate) sur le composant racine¬†: React √©vite les mises √† jour DOM superflues.

---

### `root.unmount()` {/*root-unmount*/}

Appelez `root.unmount` pour d√©truire l'arborescence de rendu au sein d'une racine React.

```js
root.unmount();
```

Une appli enti√®rement construite avec React n'appellera g√©n√©ralement pas `root.unmount`.

C'est principalement utile si le n≈ìud DOM de votre racine React (ou un de ses anc√™tres) est susceptible d'√™tre retir√© du DOM par du code tiers.  Imaginez par exemple une gestion d'onglet bas√©e sur jQuery qui retire les onglets inactifs du DOM. Si un onglet est retir√©, tout ce qu'il contient (y compris d'√©ventuelles racines React) sera √©galement retir√© du DOM. Dans un tel cas, vous devez dire √† React de ¬´¬†cesser¬†¬ª de g√©rer le contenu de la racine retir√©e en appelant `root.unmount`.  Si vous ne le faisiez pas, les composants au sein de la racine retir√©e ne pourraient pas √™tre nettoy√©s et lib√©rer leurs ressources globales, telles que des abonnements.

Un appel √† `root.unmount` d√©montera tous les composants dans cette racine et ¬´¬†d√©tachera¬†¬ª React du n≈ìud DOM racine, y compris pour la gestion √©v√©nementielle et les √©tats de l'arbre.

#### Param√®tres {/*root-unmount-parameters*/}

`root.unmount` ne prend aucun param√®tre.

#### Valeur renvoy√©e {/*root-unmount-returns*/}

`root.unmount` renvoie `undefined`.

#### Limitations {/*root-unmount-caveats*/}

* Appeler `root.unmount` d√©montera tous les composants dans cette racine et ¬´¬†d√©tachera¬†¬ª React du n≈ìud DOM racine.

* Une fois que vous avez appel√© `root.unmount`, vous ne pouvez plus rappeler `root.render` sur cette m√™me racine.  Tenter d'appeler `root.render` sur une racine d√©mont√©e l√®vera une erreur *"Cannot update an unmounted root"* *(¬´¬†Impossible de mettre √† jour une racine d√©mont√©e¬†¬ª, NdT)*. En revanche, vous pouvez cr√©er une nouvelle racine pour le m√™me n≈ìud DOM une fois la racine pr√©c√©dente pour ce n≈ìud d√©mont√©e.

---

## Utilisation {/*usage*/}

### Afficher une appli enti√®rement construite avec React {/*rendering-an-app-fully-built-with-react*/}

Si votre appli est enti√®rement construite avec React, cr√©ez une racine unique pour l'appli compl√®te.

```js [[1, 3, "document.getElementById('root')"], [2, 4, "<App />"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

En g√©n√©ral, vous n'aurez besoin de ce code qu'une fois, au d√©marrage. Il va¬†:

1. Trouver le <CodeStep step={1}>n≈ìud DOM du navigateur</CodeStep> d√©fini dans votre HTML.
2. Afficher le <CodeStep step={2}>composant React</CodeStep> de votre appli √† l'int√©rieur.

<Sandpack>

```html index.html
<!DOCTYPE html>
<html>
  <head><title>Mon appli</title></head>
  <body>
    <!-- Voici le n≈ìud DOM -->
    <div id="root"></div>
  </body>
</html>
```

```js src/index.js active
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  return (
    <>
      <h1>Salut tout le monde¬†!</h1>
      <Counter />
    </>
  );
}

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      Vous avez cliqu√© {count} fois
    </button>
  );
}
```

</Sandpack>

**Si votre appli est enti√®rement construite avec React, vous ne devriez pas avoir besoin de cr√©er davantage de racines, ni de rappeler [`root.render`](#root-render).**

√Ä partir de l√†, React g√®rera le DOM de votre appli enti√®re. Pour ajouter d'autres composants, [imbriquez-les dans le composant `App`](/learn/importing-and-exporting-components). Si vous avez besoin de mettre √† jour l'interface utilisateur (UI), chaque composant peut le faire en [utilisant l'√©tat](/reference/react/useState). Si vous souhaitez afficher du contenu compl√©mentaire (comme une bo√Æte de dialogue modale ou une infobulle) hors du n≈ìud DOM, [affichez-le dans un portail](/reference/react-dom/createPortal).

<Note>

Lorsque votre HTML est vide, l'utilisateur voit une page vierge jusqu'√† ce que le code JavaScript soit charg√© et ex√©cut√©¬†:

```html
<div id="root"></div>
```

√áa peut sembler tr√®s lent¬†! Pour rem√©dier √† √ßa, vous pouvez g√©n√©rer le HTML initial de vos composants [c√¥t√© serveur ou lors du *build*](/reference/react-dom/server). Ainsi vos visiteurs pourront lire le texte, regarder les images, et cliquer sur les liens en attendant que votre code JavaScript soit charg√©. Nous vous conseillons [d'utiliser un framework](/learn/start-a-new-react-project#production-grade-react-frameworks) qui propose ce genre d'optimisations d'entr√©e de jeu.  En fonction de son approche, il pourra s'agir de rendu c√¥t√© serveur *(SSR pour server-side rendering, NdT)* ou de g√©n√©ration de site statique *(SSG pour static-site generation, NdT)*.

</Note>

<Pitfall>

**Les applis utilisant le rendu c√¥t√© serveur ou la g√©n√©ration de site statique doivent appeler [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) plut√¥t que `createRoot`.** React *hydratera* (r√©utilisera) alors les n≈ìuds DOM de votre HTML plut√¥t que de les d√©truire pour les recr√©er ensuite.

</Pitfall>

---

### Afficher une page partiellement construite avec React {/*rendering-a-page-partially-built-with-react*/}

Si votre page [n'est pas enti√®rement construite avec React](/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page), vous pouvez appeler `createRoot` plusieurs fois, pour cr√©er une racine de rendu pour chaque bloc d'UI g√©r√© par React.  Vous pouvez alors afficher les contenus de votre choix dans chaque racine en appelant[`root.render`](#root-render).

Dans l'exemple ci-dessous, deux composants React distincts sont affich√©s dans deux n≈ìuds DOM d√©finis dans le fichier `index.html`¬†:

<Sandpack>

```html public/index.html
<!DOCTYPE html>
<html>
  <head><title>Mon appli</title></head>
  <body>
    <nav id="navigation"></nav>
    <main>
      <p>Ce paragraphe n'est pas affich√© par React (ouvrez index.html pour vous en assurer).</p>
      <section id="comments"></section>
    </main>
  </body>
</html>
```

```js src/index.js active
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode);
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode);
commentRoot.render(<Comments />);
```

```js src/Components.js
export function Navigation() {
  return (
    <ul>
      <NavLink href="/">Accueil</NavLink>
      <NavLink href="/about">√Ä propos</NavLink>
    </ul>
  );
}

function NavLink({ href, children }) {
  return (
    <li>
      <a href={href}>{children}</a>
    </li>
  );
}

export function Comments() {
  return (
    <>
      <h2>Commentaires</h2>
      <Comment text="Salut¬†!" author="Marie" />
      <Comment text="Comment √ßa va¬†?" author="Maxime" />
    </>
  );
}

function Comment({ text, author }) {
  return (
    <p>{text} ‚Äî <i>{author}</i></p>
  );
}
```

```css
nav ul { padding: 0; margin: 0; }
nav ul li { display: inline-block; margin-right: 20px; }
```

</Sandpack>

Vous pourriez aussi cr√©er un nouveau n≈ìud DOM avec [`document.createElement()`](https://developer.mozilla.org/fr/docs/Web/API/Document/createElement) et l'ajouter manuellement au document.

```js
const domNode = document.createElement('div');
const root = createRoot(domNode);
root.render(<Comment />);
document.body.appendChild(domNode); // Vous pouvez l‚Äôajouter o√π bon vous semble
```

Pour retirer l'arbre React d'un n≈ìud DOM et en nettoyer les ressources, appelez [`root.unmount`](#root-unmount).

```js
root.unmount();
```

C'est surtout utile pour les composants React figurant au sein d'une appli √©crite avec un autre framework.

---

### Mettre √† jour un composant racine {/*updating-a-root-component*/}

Vous pouvez appeler `render` plus d'une fois sur la m√™me racine. Tant que la structure de l'arbre de composants correspond √† celle d√©j√† en place, React [pr√©servera l'√©tat](/learn/preserving-and-resetting-state). Voyez comme vous pouvez taper quelque chose dans le champ, ce qui montre bien que les mises √† jour issues d'appels r√©p√©t√©s √† `render` ne sont pas destructrices¬†:

<Sandpack>

```js src/index.js active
import { createRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = createRoot(document.getElementById('root'));

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

```js src/App.js
export default function App({counter}) {
  return (
    <>
      <h1>Salut tout le monde¬†! {counter}</h1>
      <input placeholder="Tapez quelque chose ici" />
    </>
  );
}
```

</Sandpack>

Il est toutefois rare d'appeler `render` plusieurs fois.  En g√©n√©ral, vos composants [mettront plut√¥t √† jour l'√©tat](/reference/react/useState).

### Show a dialog for uncaught errors {/*show-a-dialog-for-uncaught-errors*/}

<Canary>

`onUncaughtError` is only available in the latest React Canary release.

</Canary>

By default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optional `onUncaughtError` root option:

```js [[1, 6, "onUncaughtError"], [2, 6, "error", 1], [3, 6, "errorInfo"], [4, 10, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onUncaughtError: (error, errorInfo) => {
      console.error(
        'Uncaught error',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

The <CodeStep step={1}>onUncaughtError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> that was thrown.
2. An <CodeStep step={3}>errorInfo</CodeStep> object that contains the <CodeStep step={4}>componentStack</CodeStep> of the error.

You can use the `onUncaughtError` root option to display error dialogs:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");
  
  // Set the title
  errorTitle.innerText = title;
  
  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];
  
  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }
  
  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportUncaughtError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onUncaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportUncaughtError({
        error,
        componentStack: errorInfo.componentStack
      });
    }
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  const [throwError, setThrowError] = useState(false);
  
  if (throwError) {
    foo.bar = 'baz';
  }
  
  return (
    <div>
      <span>This error shows the error dialog:</span>
      <button onClick={() => setThrowError(true)}>
        Throw error
      </button>
    </div>
  );
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "canary",
    "react-dom": "canary",
    "react-scripts": "^5.0.0"
  },
  "main": "/index.js"
}
```

</Sandpack>


### Displaying Error Boundary errors {/*displaying-error-boundary-errors*/}

<Canary>

`onCaughtError` is only available in the latest React Canary release.

</Canary>

By default, React will log all errors caught by an Error Boundary to `console.error`. To override this behavior, you can provide the optional `onCaughtError` root option to handle errors caught by an [Error Boundary](/reference/react/Component#catching-rendering-errors-with-an-error-boundary):

```js [[1, 6, "onCaughtError"], [2, 6, "error", 1], [3, 6, "errorInfo"], [4, 10, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onCaughtError: (error, errorInfo) => {
      console.error(
        'Caught error',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

The <CodeStep step={1}>onCaughtError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> that was caught by the boundary.
2. An <CodeStep step={3}>errorInfo</CodeStep> object that contains the <CodeStep step={4}>componentStack</CodeStep> of the error.

You can use the `onCaughtError` root option to display error dialogs or filter known errors from logging:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");

  // Set the title
  errorTitle.innerText = title;

  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];

  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }

  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportCaughtError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onCaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportCaughtError({
        error, 
        componentStack: errorInfo.componentStack,
      });
    }
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

export default function App() {
  const [error, setError] = useState(null);
  
  function handleUnknown() {
    setError("unknown");
  }

  function handleKnown() {
    setError("known");
  }
  
  return (
    <>
      <ErrorBoundary
        fallbackRender={fallbackRender}
        onReset={(details) => {
          setError(null);
        }}
      >
        {error != null && <Throw error={error} />}
        <span>This error will not show the error dialog:</span>
        <button onClick={handleKnown}>
          Throw known error
        </button>
        <span>This error will show the error dialog:</span>
        <button onClick={handleUnknown}>
          Throw unknown error
        </button>
      </ErrorBoundary>
      
    </>
  );
}

function fallbackRender({ resetErrorBoundary }) {
  return (
    <div role="alert">
      <h3>Error Boundary</h3>
      <p>Something went wrong.</p>
      <button onClick={resetErrorBoundary}>Reset</button>
    </div>
  );
}

function Throw({error}) {
  if (error === "known") {
    throw new Error('Known error')
  } else {
    foo.bar = 'baz';
  }
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "canary",
    "react-dom": "canary",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>

### Displaying a dialog for recoverable errors {/*displaying-a-dialog-for-recoverable-errors*/}

React may automatically render a component a second time to attempt to recover from an error thrown in render. If successful, React will log a recoverable error to the console to notify the developer. To override this behavior, you can provide the optional `onRecoverableError` root option:

```js [[1, 6, "onRecoverableError"], [2, 6, "error", 1], [3, 10, "error.cause"], [4, 6, "errorInfo"], [5, 11, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onRecoverableError: (error, errorInfo) => {
      console.error(
        'Recoverable error',
        error,
        error.cause,
        errorInfo.componentStack,
      );
    }
  }
);
root.render(<App />);
```

The <CodeStep step={1}>onRecoverableError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> that React throws. Some errors may include the original cause as <CodeStep step={3}>error.cause</CodeStep>. 
2. An <CodeStep step={4}>errorInfo</CodeStep> object that contains the <CodeStep step={5}>componentStack</CodeStep> of the error.

You can use the `onRecoverableError` root option to display error dialogs:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");

  // Set the title
  errorTitle.innerText = title;

  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];

  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }

  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportRecoverableError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onRecoverableError: (error, errorInfo) => {
    reportRecoverableError({
      error,
      cause: error.cause,
      componentStack: errorInfo.componentStack,
    });
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

// üö© Bug: Never do this. This will force an error.
let errorThrown = false;
export default function App() {
  return (
    <>
      <ErrorBoundary
        fallbackRender={fallbackRender}
      >
        {!errorThrown && <Throw />}
        <p>This component threw an error, but recovered during a second render.</p>
        <p>Since it recovered, no Error Boundary was shown, but <code>onRecoverableError</code> was used to show an error dialog.</p>
      </ErrorBoundary>
      
    </>
  );
}

function fallbackRender() {
  return (
    <div role="alert">
      <h3>Error Boundary</h3>
      <p>Something went wrong.</p>
    </div>
  );
}

function Throw({error}) {
  // Simulate an external value changing during concurrent render.
  errorThrown = true;
  foo.bar = 'baz';
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "canary",
    "react-dom": "canary",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>


---

## D√©pannage {/*troubleshooting*/}

### J'ai cr√©√© une racine mais rien ne s'affiche {/*ive-created-a-root-but-nothing-is-displayed*/}

Assurez-vous de ne pas oublier *d'afficher* effectivement votre appli (avec `render`) au sein de la racine¬†:

```js {5}
import { createRoot } from 'react-dom/client';
import App from './App.js';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

Tant que vous ne le faites pas, rien ne sera affich√©.

---

<<<<<<< HEAD
### J'ai une erreur¬†: *"Target container is not a DOM element"* {/*im-getting-an-error-target-container-is-not-a-dom-element*/}
=======
### I'm getting an error: "You passed a second argument to root.render" {/*im-getting-an-error-you-passed-a-second-argument-to-root-render*/}

A common mistake is to pass the options for `createRoot` to `root.render(...)`:

<ConsoleBlock level="error">

Warning: You passed a second argument to root.render(...) but it only accepts one argument.

</ConsoleBlock>

To fix, pass the root options to `createRoot(...)`, not `root.render(...)`:
```js {2,5}
// üö© Wrong: root.render only takes one argument.
root.render(App, {onUncaughtError});

// ‚úÖ Correct: pass options to createRoot.
const root = createRoot(container, {onUncaughtError}); 
root.render(<App />);
```

---

### I'm getting an error: "Target container is not a DOM element" {/*im-getting-an-error-target-container-is-not-a-dom-element*/}
>>>>>>> c3bc5affa0e7452e306c785af11798d16b4f6dd4

*(¬´¬†Le conteneur cible n'est pas un √©l√©ment DOM¬†¬ª, NdT)*

Cette erreur signifique que ce que vous avez pass√© √† `createRoot` n'est pas un √©l√©ment DOM.

Si vous ne comprenez pas bien ce qui se passe, essayer d'afficher des informations dans la console¬†:

```js {2}
const domNode = document.getElementById('root');
console.log(domNode); // ???
const root = createRoot(domNode);
root.render(<App />);
```

Si par exemple `domNode` est `null`, √ßa signifie que [`getElementById`](https://developer.mozilla.org/fr/docs/Web/API/Document/getElementById) a renvoy√© `null`. √áa arrive lorsqu'aucun n≈ìud du document n'a l'ID sp√©cifi√© au moment de l'appel. Il peut y avoir plusieurs raisons √† √ßa¬†:

1. L'ID que vous utilisez n'est pas tout √† fait celui utilis√© dans le HTML.  V√©rifiez les fautes de frappe¬†!
2. La balise `<script>` de votre *bundle*, si elle est synchrone (cas par d√©faut), ne peut pas ¬´¬†voir¬†¬ª les n≈ìuds DOM qui apparaissent *apr√®s* elle dans le HTML.

Il est aussi fr√©quent d'obtenir cette erreur en √©crivant par m√©garde `createRoot(<App />)` plut√¥t que `createRoot(domNode)`.

---

### J'ai une erreur¬†: *"Functions are not valid as a React child."* {/*im-getting-an-error-functions-are-not-valid-as-a-react-child*/}

*(¬´¬†Les fonctions ne constituent pas des enfants React valides¬†¬ª, NdT)*

Cette erreur signifie que ce que vous avez pass√© √† `root.render` n'est pas un composant React.

√áa peut arriver si vous appelez `root.render` en lui passant `Component` plut√¥t que `<Component />`¬†:

```js {2,5}
// üö© Erron√©¬†: App est une function, pas un composant.
root.render(App);

// ‚úÖ Correct¬†: <App /> est un composant.
root.render(<App />);
```

Ou si vous passez une fonction √† `root.render`, plut√¥t que le r√©sultat de l'appel √† cette fonction¬†:

```js {2,5}
// üö© Erron√©¬†: createApp est une fonction, pas un composant.
root.render(createApp);

// ‚úÖ Correct¬†: appeler createApp renvoie un composant.
root.render(createApp());
```

---

### Mon HTML produit c√¥t√© serveur est recr√©√© de z√©ro {/*my-server-rendered-html-gets-re-created-from-scratch*/}

Si votre appli utilise le rendu c√¥t√© serveur et inclut le HTML initial g√©n√©r√© par React, vous remarquerez peut-√™tre qu'en cr√©ant une racine pour appeler `root.render`, √ßa supprime tout ce HTML et re-cr√©e les n≈ìuds DOM de z√©ro.  √áa peut √™tre plus lent, mais surtout risque de r√©initialiser le focus et la position de d√©filement tout en perdant les saisies de l'utilisateur.

Les applis qui font un rendu c√¥t√© serveur doivent utiliser [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) plut√¥t que `createRoot`¬†:

```js {1,4-7}
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);
```

Remarquez que l'API est diff√©rente. En particulier, il n'y aura g√©n√©ralement pas d'appel ult√©rieur √† `root.render`.
